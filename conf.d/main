#!/bin/bash -ex

export VERSION_CANVAS=prod

export SRC=/usr/local/src
export WEBROOT=/var/www/canvas
export APPROOT=/usr/src/app

export ADMIN_PASS=turnkey1
export ADMIN_MAIL=admin@example.com
export DOMAIN=www.example.com

export DB_USER=canvas
export DB_NAME=canvas_production
export DB_PASS=turnkey1
export DB_QUEUE=canvas_queue_production

download() {
    [ "$FAB_HTTP_PROXY" ] && PROXY="--proxy $FAB_HTTP_PROXY"
    cd $2; curl -L -f -O $PROXY $1; cd -
}

# download and set branch to version
URL="https://github.com/instructure/canvas-lms.git"

[ "$FAB_HTTP_PROXY" ] && export HTTP_PROXY=$FAB_HTTP_PROXY
git clone "$URL" "$WEBROOT" --depth=1 -b "$VERSION_CANVAS"
unset HTTP_PROXY

cd $WEBROOT

# setup database config
cat >$WEBROOT/config/database.yml<<EOF
production:
  adapter: postgresql
  encoding: utf8
  host: localhost
  database: $DB_NAME
  username: $DB_USER
  password: $DB_PASS
  timeout: 5000
EOF

# setup email config
cat >$WEBROOT/config/outgoing_mail.yml<<EOF
production:
  tls: false
  delivery_method: "sendmail"
  enable_starttls_auto: false
  address: "host.containers.internal"
  port: "25"
  domain: "$DOMAIN"
  outgoing_address: "$ADMIN_MAIL"
  default_name: "TurnKey Canvas"
EOF

# setup domain config
cat >$WEBROOT/config/domain.yml<<EOF
production:
  domain: "$DOMAIN"
  ssl: true
EOF

# setup cache store config
cat >$WEBROOT/config/cache_store.yml<<EOF
production:
  cache_store: redis_cache_store
EOF

cat >$WEBROOT/config/redis.yml<<EOF
production:
  url:
  - redis://localhost
EOF

cat >$WEBROOT/config/delayed_jobs.yml<<EOF
production:
  workers:
  - queue: canvas_queue
    workers: 2
    max_priority: 10
  - queue: canvas_queue
    workers: 2

  max_run_time: 28800
  worker_max_job_count: 20
  worker_max_memory_usage: 536870912

default:
  workers:
  - queue: canvas_queue
EOF

# Canvas Rich Content Editor API
cat >$WEBROOT/config/vault_contents.yml<<EOF
production:
  'app-canvas/data/secrets':
    data:
      canvas_security:
        encryption_secret: "turnkey1"
        signing_secret: "turnkey1"
EOF

cat >$WEBROOT/config/security.yml<<EOF
production: &default
  # replace this with a random string of at least 20 characters
  encryption_key: 1234512345123451234512345123451234512345123451234512345
  lti_iss: 'https://canvas.instructure.com'
EOF

cat >$WEBROOT/config/dynamic_settings.yml<<EOF
production:
  config:
    canvas:
      rich-content-service:
        app-host: "http://localhost:3000"
EOF

# copy example configurations

CONFIGS=( amazon_s3 file_store external_migration )

for config in "${configs[@]}"; do
  cp "config/$config.yml.example" "config/$config.yml";
done

# tweak footer
sed -i "s|</footer>| \
<div id='turnkey-credit' style='text-align:center; padding-top:20px;'> \
  <a href='https://www.turnkeylinux.org/canvas'>Canvas Appliance</a> \
  - Powered by <a href='https://www.turnkeylinux.org'>TurnKey Linux</a> \
</div> \
</footer>| \
" "$WEBROOT/app/views/layouts/application.html.erb"

# tweak Dockerfile
sed -i 's|\(rm -rf node_modules\)|\1 /home/docker/.cache /home/docker/.gem/3.3/cache /usr/src/app/public/dist/webpack-dev|' Dockerfile.production

# tweak confconsole so it doesn't show podman NIC by default
sed '/^#default_nic/s/^#//' /etc/confconsole/confconsole.conf

### all of the following would be similar for all containerized appliances

# clean up build fs
fs_cleanup() {
  set +e
  mount -l -t fuse.fuse-overlayfs | cut -d " " -f3 | xargs -rL1 fusermount -u
  umount -vRf /sys
  rm /dev/fuse
}

# umount everything if build fails or deck won't umount
trap fs_cleanup INT TERM EXIT

# podman requires sysfs & cgroups
# fuse-overlayfs requires fusectl & fuse device
# native overlayfs refuses to work on top of deck overlayfs
# vfs works; it is heavier and slower and incompatible with overlay but less fragile
mount -t sysfs sysfs /sys -o ro,nosuid,nodev,noexec,relatime
mkdir -p /sys/fs/{cgroup,fuse/connections}
mount -t cgroup2 cgroup2 /sys/fs/cgroup -o rw,nosuid,nodev,noexec,relatime
mount -t fusectl fusectl /sys/fs/fuse/connections -o rw,nosuid,nodev,noexec,relatime
mknod /dev/fuse -m 0666 c 10 229

# get deps
RUBY_VERSION="$(grep -Po '^ARG RUBY[= ]\K.+$' Dockerfile.production)"
RUBY_IMAGE="$(grep -Po '^FROM \K[^:]*' Dockerfile.production)"
PG_VERSION="$(grep -Po 'POSTGRES_CLIENT[= ]\K[[:digit:]]+' Dockerfile.production)"

BUILD_DEPS=( "$RUBY_IMAGE:$RUBY_VERSION" )
RUN_DEPS=( "postgres:$PG_VERSION-alpine" nginx:alpine redis:alpine instructure/canvas-rce-api )
DEPS=( "${BUILD_DEPS[@]}" "${RUN_DEPS[@]}" )

export RUBY_VERSION RUBY_IMAGE PG_VERSION BUILD_DEPS RUN_DEPS DEPS
for i in ${DEPS[@]}; do podman pull "docker.io/$i"; done

# build image
# retry a few times because of possible network issues ruining the build
for i in $(seq 1 3); do
  podman build --isolation chroot -t canvas -f Dockerfile.production .
done

for i in canvas "${RUN_DEPS[@]}"; do
  NAME="$(basename "$i" | cut -d':' -f1)"
  podman save --format oci-dir -o "$SRC/images/$NAME" "$i"
done

podman system reset -f
